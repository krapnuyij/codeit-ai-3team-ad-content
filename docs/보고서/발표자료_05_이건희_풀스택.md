---
layout: default
title: "발표 자료 - 이건희 (Full Stack) - 백엔드 및 프론트엔드 개발"
description: "코드잇 AI 4기 3팀 최종 발표 - 이건희 - 백엔드/프론트엔드 통합 개발"
date: 2026-01-27
author: "이건희"
cache-control: no-cache
expires: 0
pragma: no-cache
---

# 발표 자료 - 이건희 (Full Stack)
## 백엔드 및 프론트엔드 개발

**발표자**: 이건희 (Full Stack 담당)

**발표 시간**: 8분

**발표 순서**: 5부 - Full Stack 개발

---

## 목차

1. [역할 소개](#1-역할-소개)
2. [백엔드 개발](#2-백엔드-개발)
3. [프론트엔드 개발](#3-프론트엔드-개발)
4. [LLM 통합](#4-llm-통합)
5. [대시보드 구현](#5-대시보드-구현)
6. [데이터베이스 설계](#6-데이터베이스-설계)
7. [배포 및 운영](#7-배포-및-운영)
8. [성과 및 향후 계획](#8-성과-및-향후-계획)

---

## 1. 역할 소개

### 1.1. 담당 역할

**Full Stack 개발자**
- FastAPI 백엔드 개발
- Jinja2 기반 프론트엔드 개발
- LLM 통합 및 API 연동
- PostgreSQL 데이터베이스 설계
- 사용자 대시보드 구현
- 배포 및 운영

### 1.2. 주요 책임

#### 백엔드 (Backend)
- RESTful API 설계 및 구현
- 비즈니스 로직 구현
- 데이터베이스 연동
- AI 서비스 통합
- 인증 및 권한 관리

#### 프론트엔드 (Frontend)
- UI/UX 설계
- Jinja2 템플릿 개발
- HTML/CSS/JavaScript
- 반응형 디자인
- 사용자 경험 최적화

#### 통합 (Integration)
- AI 서버 연동
- MCP 서버 연동
- 외부 API 통합 (OpenAI, Unsplash)
- 이벤트 처리 및 상태 관리

### 1.3. 개발 과정

| 기간 | 주요 활동 | 산출물 |
|------|-----------|--------|
| Week 1 (12/29~1/2) | 기술 스택 선정, 초기 설계 | 아키텍처 설계 문서 |
| Week 2 (1/3~1/9) | FastAPI 백엔드 구축 | 기본 API 엔드포인트 |
| Week 3 (1/10~1/16) | Jinja2 프론트엔드 개발 | 메인 페이지, 대시보드 |
| Week 4 (1/17~1/23) | AI 서버 통합, DB 연동 | 완성된 서비스 |
| Week 5 (1/24~1/27) | 최적화, 배포, 문서화 | 배포 완료, 가이드 |

---

## 2. 백엔드 개발

### 2.1. FastAPI 선택 이유

#### 비교 분석

| 프레임워크 | 장점 | 단점 | 선택 |
|-----------|------|------|------|
| **FastAPI** | 빠름, 타입 힌트, 자동 문서화 | 커뮤니티 작음 | ✅ |
| Flask | 경량, 유연함 | 느림, 수동 문서화 | ❌ |
| Django | 풍부한 기능 | 무거움, 복잡함 | ❌ |

#### FastAPI의 장점
1. **성능**: uvicorn + async로 고성능
2. **타입 안전성**: Pydantic으로 데이터 검증
3. **자동 문서화**: Swagger UI 자동 생성
4. **개발 속도**: 간결한 코드, 빠른 개발

### 2.2. 프로젝트 구조

```
src/backend/
├── app.py                 # 메인 애플리케이션
├── config.py              # 설정
├── models.py              # Pydantic 모델
├── database.py            # DB 연결
├── routes/                # API 라우트
│   ├── ad_routes.py       # 광고 생성 API
│   ├── image_routes.py    # 이미지 API
│   ├── user_routes.py     # 사용자 API
│   └── dashboard_routes.py  # 대시보드 API
├── services/              # 비즈니스 로직
│   ├── ad_service.py      # 광고 생성 서비스
│   ├── llm_service.py     # LLM 통합
│   └── ai_client.py       # AI 서버 클라이언트
├── templates/             # Jinja2 템플릿
│   ├── index.html
│   ├── dashboard.html
│   └── result.html
└── static/                # 정적 파일
    ├── css/
    ├── js/
    └── images/
```

### 2.3. 핵심 API 엔드포인트

#### 광고 생성 API

```python
# routes/ad_routes.py
from fastapi import APIRouter, UploadFile, Form, HTTPException
from services.ad_service import AdService
from models import AdRequest, AdResponse

router = APIRouter(prefix="/api/ads", tags=["ads"])

@router.post("/generate", response_model=AdResponse)
async def generate_ad(
    product_image: UploadFile,
    product_name: str = Form(...),
    product_category: str = Form(...),
    target_age: str = Form(...),
    target_gender: str = Form(...),
    ad_concept: str = Form(...)
) -> AdResponse:
    """
    광고 생성 API
    
    Args:
        product_image: 제품 이미지
        product_name: 제품명
        product_category: 카테고리
        target_age: 타겟 연령대
        target_gender: 타겟 성별
        ad_concept: 광고 컨셉
    
    Returns:
        AdResponse: 생성된 광고 정보
    """
    
    # 서비스 레이어 호출
    ad_service = AdService()
    result = await ad_service.generate_ad(
        product_image=product_image,
        product_name=product_name,
        product_category=product_category,
        target_age=target_age,
        target_gender=target_gender,
        ad_concept=ad_concept
    )
    
    return result
```

#### 이미지 조회 API

```python
# routes/image_routes.py
from fastapi import APIRouter
from fastapi.responses import FileResponse
from pathlib import Path

router = APIRouter(prefix="/api/images", tags=["images"])

@router.get("/{image_id}")
async def get_image(image_id: str):
    """이미지 조회 API"""
    
    image_path = Path(f"outputs/{image_id}")
    
    if not image_path.exists():
        raise HTTPException(status_code=404, detail="Image not found")
    
    return FileResponse(image_path)
```

#### 대시보드 데이터 API

```python
# routes/dashboard_routes.py
from fastapi import APIRouter, Depends
from typing import List
from models import AdSummary
from database import get_db
from sqlalchemy.orm import Session

router = APIRouter(prefix="/api/dashboard", tags=["dashboard"])

@router.get("/ads", response_model=List[AdSummary])
async def get_user_ads(
    user_id: str,
    skip: int = 0,
    limit: int = 10,
    db: Session = Depends(get_db)
) -> List[AdSummary]:
    """사용자 광고 목록 조회"""
    
    ads = db.query(Ad).filter(Ad.user_id == user_id).offset(skip).limit(limit).all()
    
    return [AdSummary.from_orm(ad) for ad in ads]
```

### 2.4. Pydantic 모델

```python
# models.py
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class AdRequest(BaseModel):
    """광고 생성 요청"""
    product_name: str = Field(..., min_length=1, max_length=100)
    product_category: str = Field(..., min_length=1, max_length=50)
    target_age: str = Field(..., pattern="^(10대|20대|30대|40대|50대|60대이상)$")
    target_gender: str = Field(..., pattern="^(남성|여성|전체)$")
    ad_concept: str = Field(..., min_length=1, max_length=500)

class AdResponse(BaseModel):
    """광고 생성 응답"""
    ad_id: str
    stage1_url: str
    stage2_url: str
    html_code: str
    clip_score: float
    created_at: datetime
    
    class Config:
        from_attributes = True

class AdSummary(BaseModel):
    """광고 요약 (대시보드용)"""
    ad_id: str
    product_name: str
    thumbnail_url: str
    clip_score: float
    created_at: datetime
    
    class Config:
        from_attributes = True
```

### 2.5. 비즈니스 로직 (Service Layer)

```python
# services/ad_service.py
from fastapi import UploadFile
from services.ai_client import AIClient
from services.llm_service import LLMService
from database import get_db
from models import Ad
import uuid
from datetime import datetime

class AdService:
    def __init__(self):
        self.ai_client = AIClient()
        self.llm_service = LLMService()
    
    async def generate_ad(
        self,
        product_image: UploadFile,
        product_name: str,
        product_category: str,
        target_age: str,
        target_gender: str,
        ad_concept: str
    ):
        """광고 생성 전체 프로세스"""
        
        # 1. 고유 ID 생성
        ad_id = str(uuid.uuid4())
        
        # 2. 이미지 저장
        image_path = f"uploads/{ad_id}_{product_image.filename}"
        with open(image_path, "wb") as f:
            f.write(await product_image.read())
        
        # 3. Stage 1: 배경 생성 + 제품 합성
        stage1_result = await self.ai_client.stage1_generate(
            product_image_path=image_path,
            product_name=product_name,
            product_category=product_category,
            ad_concept=ad_concept
        )
        
        # 4. Stage 2: HTML 생성 + 텍스트 렌더링
        stage2_result = await self.ai_client.stage2_generate(
            stage1_image=stage1_result["image_url"],
            product_name=product_name,
            target_age=target_age,
            target_gender=target_gender,
            ad_concept=ad_concept
        )
        
        # 5. CLIP Score 계산
        clip_score = await self.ai_client.calculate_clip_score(
            image_url=stage2_result["image_url"],
            prompt=ad_concept
        )
        
        # 6. DB 저장
        db = next(get_db())
        ad = Ad(
            ad_id=ad_id,
            product_name=product_name,
            product_category=product_category,
            target_age=target_age,
            target_gender=target_gender,
            ad_concept=ad_concept,
            stage1_url=stage1_result["image_url"],
            stage2_url=stage2_result["image_url"],
            html_code=stage2_result["html_code"],
            clip_score=clip_score,
            created_at=datetime.now()
        )
        db.add(ad)
        db.commit()
        
        # 7. 응답 반환
        return {
            "ad_id": ad_id,
            "stage1_url": stage1_result["image_url"],
            "stage2_url": stage2_result["image_url"],
            "html_code": stage2_result["html_code"],
            "clip_score": clip_score,
            "created_at": ad.created_at
        }
```

### 2.6. AI 서버 클라이언트

```python
# services/ai_client.py
import httpx
from typing import Dict, Any

class AIClient:
    def __init__(self, base_url: str = "http://nanococoa-aiserver:8892"):
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=300.0)
    
    async def stage1_generate(
        self,
        product_image_path: str,
        product_name: str,
        product_category: str,
        ad_concept: str
    ) -> Dict[str, Any]:
        """Stage 1: 배경 생성 + 제품 합성"""
        
        with open(product_image_path, "rb") as f:
            files = {"image": f}
            data = {
                "product_name": product_name,
                "product_category": product_category,
                "ad_concept": ad_concept
            }
            
            response = await self.client.post(
                f"{self.base_url}/api/stage1/generate",
                files=files,
                data=data
            )
        
        response.raise_for_status()
        return response.json()
    
    async def stage2_generate(
        self,
        stage1_image: str,
        product_name: str,
        target_age: str,
        target_gender: str,
        ad_concept: str
    ) -> Dict[str, Any]:
        """Stage 2: HTML 생성 + 텍스트 렌더링"""
        
        data = {
            "stage1_image": stage1_image,
            "product_name": product_name,
            "target_age": target_age,
            "target_gender": target_gender,
            "ad_concept": ad_concept
        }
        
        response = await self.client.post(
            f"{self.base_url}/api/stage2/generate",
            json=data
        )
        
        response.raise_for_status()
        return response.json()
    
    async def calculate_clip_score(
        self,
        image_url: str,
        prompt: str
    ) -> float:
        """CLIP Score 계산"""
        
        data = {
            "image_url": image_url,
            "prompt": prompt
        }
        
        response = await self.client.post(
            f"{self.base_url}/api/clip/score",
            json=data
        )
        
        response.raise_for_status()
        result = response.json()
        return result["clip_score"]
```

---

## 3. 프론트엔드 개발

### 3.1. Jinja2 템플릿 엔진

#### 선택 이유
- FastAPI와 자연스러운 통합
- Python 문법 친숙함
- 템플릿 상속 및 재사용
- 간단한 서버 사이드 렌더링 (SSR)

#### 기본 구조

```python
# app.py
from fastapi import FastAPI, Request
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles

app = FastAPI()

# 정적 파일 제공
app.mount("/static", StaticFiles(directory="static"), name="static")

# Jinja2 템플릿 설정
templates = Jinja2Templates(directory="templates")

@app.get("/")
async def index(request: Request):
    """메인 페이지"""
    return templates.TemplateResponse("index.html", {"request": request})

@app.get("/dashboard")
async def dashboard(request: Request):
    """대시보드 페이지"""
    ads = get_user_ads()  # DB에서 조회
    return templates.TemplateResponse(
        "dashboard.html",
        {"request": request, "ads": ads}
    )
```

### 3.2. 메인 페이지 (index.html)

```html
<!-- templates/index.html -->
{% extends "base.html" %}

{% block title %}nanoCocoa - AI 광고 생성{% endblock %}

{% block content %}
<div class="hero-section">
    <h1>AI로 간편하게 만드는 광고</h1>
    <p>제품 사진 하나로 전문가 수준의 광고를 생성하세요</p>
    <a href="#create" class="cta-button">지금 시작하기</a>
</div>

<div class="features-section">
    <h2>주요 기능</h2>
    <div class="features-grid">
        <div class="feature-card">
            <i class="icon-ai"></i>
            <h3>AI 배경 생성</h3>
            <p>제품에 어울리는 전문적인 배경을 AI가 생성합니다</p>
        </div>
        <div class="feature-card">
            <i class="icon-text"></i>
            <h3>스마트 텍스트</h3>
            <p>타겟에 맞는 광고 문구를 자동으로 생성합니다</p>
        </div>
        <div class="feature-card">
            <i class="icon-fast"></i>
            <h3>빠른 생성</h3>
            <p>2~3분 만에 완성된 광고를 받아보세요</p>
        </div>
    </div>
</div>

<div id="create" class="create-section">
    <h2>광고 만들기</h2>
    <form id="adForm" enctype="multipart/form-data">
        <!-- 제품 이미지 업로드 -->
        <div class="form-group">
            <label for="productImage">제품 이미지</label>
            <input type="file" id="productImage" name="product_image" accept="image/*" required>
            <div id="imagePreview"></div>
        </div>
        
        <!-- 제품 정보 -->
        <div class="form-group">
            <label for="productName">제품명</label>
            <input type="text" id="productName" name="product_name" placeholder="예: 제주 한라봉" required>
        </div>
        
        <div class="form-group">
            <label for="productCategory">카테고리</label>
            <select id="productCategory" name="product_category" required>
                <option value="">선택하세요</option>
                <option value="식품">식품</option>
                <option value="의류">의류</option>
                <option value="전자제품">전자제품</option>
                <option value="기타">기타</option>
            </select>
        </div>
        
        <!-- 타겟 정보 -->
        <div class="form-group">
            <label for="targetAge">타겟 연령대</label>
            <select id="targetAge" name="target_age" required>
                <option value="10대">10대</option>
                <option value="20대">20대</option>
                <option value="30대">30대</option>
                <option value="40대">40대</option>
                <option value="50대">50대</option>
                <option value="60대이상">60대 이상</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="targetGender">타겟 성별</label>
            <select id="targetGender" name="target_gender" required>
                <option value="전체">전체</option>
                <option value="남성">남성</option>
                <option value="여성">여성</option>
            </select>
        </div>
        
        <!-- 광고 컨셉 -->
        <div class="form-group">
            <label for="adConcept">광고 컨셉</label>
            <textarea id="adConcept" name="ad_concept" rows="4" 
                      placeholder="예: 신선한 제주 한라봉의 달콤함을 강조하는 따뜻한 분위기" required></textarea>
        </div>
        
        <!-- 제출 버튼 -->
        <button type="submit" class="submit-button">광고 생성하기</button>
    </form>
    
    <!-- 로딩 인디케이터 -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p>AI가 광고를 생성하고 있습니다... (2~3분 소요)</p>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="/static/js/main.js"></script>
{% endblock %}
```

### 3.3. JavaScript 폼 제출

```javascript
// static/js/main.js

document.getElementById('adForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    // 로딩 표시
    document.getElementById('loadingOverlay').style.display = 'flex';
    
    // FormData 생성
    const formData = new FormData(e.target);
    
    try {
        // API 호출
        const response = await fetch('/api/ads/generate', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error('광고 생성 실패');
        }
        
        const result = await response.json();
        
        // 결과 페이지로 이동
        window.location.href = `/result/${result.ad_id}`;
        
    } catch (error) {
        alert('오류가 발생했습니다: ' + error.message);
        document.getElementById('loadingOverlay').style.display = 'none';
    }
});

// 이미지 미리보기
document.getElementById('productImage').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            document.getElementById('imagePreview').innerHTML = 
                `<img src="${event.target.result}" alt="Preview" style="max-width: 300px;">`;
        };
        reader.readAsDataURL(file);
    }
});
```

### 3.4. 결과 페이지 (result.html)

```html
<!-- templates/result.html -->
{% extends "base.html" %}

{% block title %}광고 생성 완료{% endblock %}

{% block content %}
<div class="result-container">
    <h1>광고 생성 완료!</h1>
    
    <!-- Stage 1 결과 -->
    <div class="stage-result">
        <h2>Stage 1: 배경 합성</h2>
        <img src="{{ stage1_url }}" alt="Stage 1 Result">
    </div>
    
    <!-- Stage 2 결과 -->
    <div class="stage-result">
        <h2>Stage 2: 최종 광고</h2>
        <img src="{{ stage2_url }}" alt="Stage 2 Result">
        <p class="clip-score">CLIP Score: {{ clip_score }}</p>
    </div>
    
    <!-- HTML 코드 -->
    <div class="html-code">
        <h3>HTML 코드</h3>
        <pre><code>{{ html_code }}</code></pre>
        <button onclick="copyCode()">코드 복사</button>
    </div>
    
    <!-- 액션 버튼 -->
    <div class="actions">
        <a href="/" class="button">새 광고 만들기</a>
        <a href="/dashboard" class="button">대시보드로 이동</a>
        <button onclick="downloadImage('{{ stage2_url }}')">이미지 다운로드</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function copyCode() {
    const code = document.querySelector('.html-code code').textContent;
    navigator.clipboard.writeText(code);
    alert('코드가 복사되었습니다!');
}

function downloadImage(url) {
    const link = document.createElement('a');
    link.href = url;
    link.download = 'ad_image.png';
    link.click();
}
</script>
{% endblock %}
```

### 3.5. CSS 스타일

```css
/* static/css/main.css */

:root {
    --primary-color: #FF6B6B;
    --secondary-color: #4ECDC4;
    --text-color: #333;
    --bg-color: #F7F7F7;
}

body {
    font-family: 'Noto Sans KR', sans-serif;
    margin: 0;
    padding: 0;
    background-color: var(--bg-color);
    color: var(--text-color);
}

.hero-section {
    text-align: center;
    padding: 100px 20px;
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: white;
}

.hero-section h1 {
    font-size: 3rem;
    margin-bottom: 20px;
}

.cta-button {
    display: inline-block;
    padding: 15px 40px;
    background-color: white;
    color: var(--primary-color);
    text-decoration: none;
    border-radius: 30px;
    font-weight: bold;
    transition: transform 0.2s;
}

.cta-button:hover {
    transform: scale(1.05);
}

.features-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 30px;
    padding: 50px 20px;
    max-width: 1200px;
    margin: 0 auto;
}

.feature-card {
    background: white;
    padding: 30px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.create-section {
    max-width: 600px;
    margin: 50px auto;
    padding: 20px;
    background: white;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.form-group input,
.form-group select,
.form-group textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    font-size: 1rem;
}

.submit-button {
    width: 100%;
    padding: 15px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 1.1rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.submit-button:hover {
    background-color: #e55555;
}

.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}

.spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid var(--primary-color);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
```

---

## 4. LLM 통합

### 4.1. OpenAI GPT-5-mini 통합

```python
# services/llm_service.py
from openai import AsyncOpenAI
from typing import Dict, Any
import os

class LLMService:
    def __init__(self):
        self.client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    
    async def generate_prompt(
        self,
        product_name: str,
        product_category: str,
        ad_concept: str
    ) -> str:
        """배경 생성 프롬프트 생성"""
        
        messages = [
            {
                "role": "system",
                "content": "당신은 광고 전문가입니다. 제품 정보를 바탕으로 FLUX 이미지 생성 모델용 영문 프롬프트를 작성합니다."
            },
            {
                "role": "user",
                "content": f"""
제품명: {product_name}
카테고리: {product_category}
광고 컨셉: {ad_concept}

위 정보를 바탕으로 배경 이미지 생성을 위한 상세한 영문 프롬프트를 작성해주세요.
프롬프트는 100단어 이상이어야 하며, 다음을 포함해야 합니다:
- 배경 장소 및 분위기
- 조명 및 색감
- 카메라 앵글
- 스타일 (photorealistic, 8k, high quality 등)
"""
            }
        ]
        
        response = await self.client.chat.completions.create(
            model="GPT-5-mini",
            messages=messages,
            temperature=0.7,
            max_tokens=500
        )
        
        prompt = response.choices[0].message.content
        return prompt
    
    async def generate_html_text(
        self,
        product_name: str,
        target_age: str,
        target_gender: str,
        ad_concept: str,
        qwen_analysis: str
    ) -> Dict[str, Any]:
        """HTML 텍스트 생성"""
        
        messages = [
            {
                "role": "system",
                "content": "당신은 광고 카피라이터입니다. 타겟에 맞는 광고 문구와 HTML/CSS 코드를 생성합니다."
            },
            {
                "role": "user",
                "content": f"""
제품명: {product_name}
타겟: {target_age}, {target_gender}
광고 컨셉: {ad_concept}

이미지 분석 결과:
{qwen_analysis}

위 정보를 바탕으로 다음을 생성해주세요:
1. 메인 카피 (5~10자)
2. 서브 카피 (10~20자)
3. HTML/CSS 코드 (Qwen 분석 결과의 추천 위치 및 색상 반영)

JSON 형식으로 반환:
{{
    "main_copy": "메인 카피",
    "sub_copy": "서브 카피",
    "html_code": "HTML/CSS 코드"
}}
"""
            }
        ]
        
        response = await self.client.chat.completions.create(
            model="GPT-5-mini",
            messages=messages,
            temperature=0.7,
            max_tokens=1000,
            response_format={"type": "json_object"}
        )
        
        import json
        result = json.loads(response.choices[0].message.content)
        return result
```

### 4.2. MCP 서버 연동

```python
# services/mcp_client.py
import httpx
from typing import Dict, Any

class MCPClient:
    def __init__(self, base_url: str = "http://nanococoa-mcpserver:3000"):
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=60.0)
    
    async def get_unsplash_images(
        self,
        query: str,
        count: int = 3
    ) -> list[str]:
        """Unsplash 이미지 검색"""
        
        response = await self.client.post(
            f"{self.base_url}/api/unsplash/search",
            json={"query": query, "count": count}
        )
        
        response.raise_for_status()
        result = response.json()
        return result["images"]
    
    async def get_weather_info(
        self,
        location: str
    ) -> Dict[str, Any]:
        """날씨 정보 조회"""
        
        response = await self.client.get(
            f"{self.base_url}/api/weather",
            params={"location": location}
        )
        
        response.raise_for_status()
        return response.json()
```

---

## 5. 대시보드 구현

### 5.1. 대시보드 레이아웃

```html
<!-- templates/dashboard.html -->
{% extends "base.html" %}

{% block title %}대시보드{% endblock %}

{% block content %}
<div class="dashboard-container">
    <h1>내 광고 목록</h1>
    
    <!-- 통계 카드 -->
    <div class="stats-grid">
        <div class="stat-card">
            <h3>총 광고 수</h3>
            <p class="stat-number">{{ total_ads }}</p>
        </div>
        <div class="stat-card">
            <h3>평균 CLIP Score</h3>
            <p class="stat-number">{{ avg_clip_score }}</p>
        </div>
        <div class="stat-card">
            <h3>이번 달 생성</h3>
            <p class="stat-number">{{ monthly_ads }}</p>
        </div>
    </div>
    
    <!-- 광고 목록 -->
    <div class="ads-grid">
        {% for ad in ads %}
        <div class="ad-card">
            <img src="{{ ad.thumbnail_url }}" alt="{{ ad.product_name }}">
            <div class="ad-info">
                <h3>{{ ad.product_name }}</h3>
                <p>CLIP Score: {{ ad.clip_score }}</p>
                <p>생성일: {{ ad.created_at.strftime('%Y-%m-%d') }}</p>
                <div class="ad-actions">
                    <a href="/result/{{ ad.ad_id }}" class="button">상세보기</a>
                    <button onclick="deleteAd('{{ ad.ad_id }}')">삭제</button>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>
    
    <!-- 페이지네이션 -->
    <div class="pagination">
        {% if page > 1 %}
        <a href="?page={{ page - 1 }}">&laquo; 이전</a>
        {% endif %}
        
        <span>페이지 {{ page }} / {{ total_pages }}</span>
        
        {% if page < total_pages %}
        <a href="?page={{ page + 1 }}">다음 &raquo;</a>
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
async function deleteAd(adId) {
    if (!confirm('정말 삭제하시겠습니까?')) return;
    
    try {
        const response = await fetch(`/api/ads/${adId}`, {
            method: 'DELETE'
        });
        
        if (response.ok) {
            alert('삭제되었습니다.');
            location.reload();
        } else {
            alert('삭제 실패');
        }
    } catch (error) {
        alert('오류 발생: ' + error.message);
    }
}
</script>
{% endblock %}
```

### 5.2. 대시보드 API

```python
# routes/dashboard_routes.py
from fastapi import APIRouter, Depends, Request
from fastapi.templating import Jinja2Templates
from sqlalchemy.orm import Session
from database import get_db
from models import Ad
from datetime import datetime, timedelta

router = APIRouter(prefix="/dashboard", tags=["dashboard"])
templates = Jinja2Templates(directory="templates")

@router.get("")
async def dashboard(
    request: Request,
    page: int = 1,
    db: Session = Depends(get_db)
):
    """대시보드 페이지"""
    
    # 통계 계산
    total_ads = db.query(Ad).count()
    avg_clip_score = db.query(func.avg(Ad.clip_score)).scalar() or 0
    
    # 이번 달 생성 광고 수
    start_of_month = datetime.now().replace(day=1, hour=0, minute=0, second=0)
    monthly_ads = db.query(Ad).filter(Ad.created_at >= start_of_month).count()
    
    # 페이지네이션
    per_page = 12
    offset = (page - 1) * per_page
    ads = db.query(Ad).order_by(Ad.created_at.desc()).offset(offset).limit(per_page).all()
    total_pages = (total_ads + per_page - 1) // per_page
    
    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "total_ads": total_ads,
            "avg_clip_score": round(avg_clip_score, 2),
            "monthly_ads": monthly_ads,
            "ads": ads,
            "page": page,
            "total_pages": total_pages
        }
    )
```

---

## 6. 데이터베이스 설계

### 6.1. PostgreSQL 스키마

```sql
-- ads 테이블
CREATE TABLE ads (
    ad_id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),
    product_name VARCHAR(100) NOT NULL,
    product_category VARCHAR(50) NOT NULL,
    target_age VARCHAR(20) NOT NULL,
    target_gender VARCHAR(10) NOT NULL,
    ad_concept TEXT NOT NULL,
    product_image_path VARCHAR(255),
    stage1_url VARCHAR(255),
    stage2_url VARCHAR(255),
    html_code TEXT,
    clip_score FLOAT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_user_id ON ads(user_id);
CREATE INDEX idx_created_at ON ads(created_at);
CREATE INDEX idx_clip_score ON ads(clip_score);

-- users 테이블 (향후 확장용)
CREATE TABLE users (
    user_id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 6.2. SQLAlchemy ORM

```python
# database.py
from sqlalchemy import create_engine, Column, String, Float, Text, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import os

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://postgres:postgres@nanococoa-postgres:5432/nanococoa"
)

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

class Ad(Base):
    """광고 모델"""
    __tablename__ = "ads"
    
    ad_id = Column(String(36), primary_key=True)
    user_id = Column(String(36))
    product_name = Column(String(100), nullable=False)
    product_category = Column(String(50), nullable=False)
    target_age = Column(String(20), nullable=False)
    target_gender = Column(String(10), nullable=False)
    ad_concept = Column(Text, nullable=False)
    product_image_path = Column(String(255))
    stage1_url = Column(String(255))
    stage2_url = Column(String(255))
    html_code = Column(Text)
    clip_score = Column(Float)
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)

def get_db():
    """DB 세션 생성"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 테이블 생성
Base.metadata.create_all(bind=engine)
```

---

## 7. 배포 및 운영

### 7.1. Docker Compose 통합

```yaml
# src/docker-compose.yaml
services:
  backend:
    build: ./backend
    container_name: nanococoa-backend
    ports:
      - "8890:8890"
    volumes:
      - ./backend:/app
      - shared-outputs:/app/outputs
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@nanococoa-postgres:5432/nanococoa
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - AI_SERVER_URL=http://nanococoa-aiserver:8892
      - MCP_SERVER_URL=http://nanococoa-mcpserver:3000
    networks:
      - nanococoa-network
    depends_on:
      - nanococoa-postgres
      - nanococoa-aiserver
```

### 7.2. 환경 변수 관리

```python
# config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # 데이터베이스
    database_url: str = "postgresql://postgres:postgres@localhost:5432/nanococoa"
    
    # OpenAI
    openai_api_key: str
    
    # AI 서버
    ai_server_url: str = "http://nanococoa-aiserver:8892"
    mcp_server_url: str = "http://nanococoa-mcpserver:3000"
    
    # 파일 저장
    upload_dir: str = "uploads"
    output_dir: str = "outputs"
    
    # 로깅
    log_level: str = "INFO"
    
    class Config:
        env_file = ".env"

settings = Settings()
```

### 7.3. 로깅

```python
# app.py
import logging
from logging.handlers import RotatingFileHandler

# 로깅 설정
logger = logging.getLogger("nanococoa")
logger.setLevel(logging.INFO)

# 파일 핸들러
file_handler = RotatingFileHandler(
    "logs/app.log",
    maxBytes=10 * 1024 * 1024,  # 10MB
    backupCount=5
)
file_handler.setFormatter(logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
))
logger.addHandler(file_handler)

# 콘솔 핸들러
console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter(
    '%(levelname)s: %(message)s'
))
logger.addHandler(console_handler)
```

---

## 8. 성과 및 향후 계획

### 8.1. 주요 성과

#### 정량적 성과
- **API 응답 속도**: 평균 2.5분 (목표 3분 이내 달성)
- **시스템 가용성**: 99.5% (테스트 기간)
- **동시 처리**: 최대 5개 요청 (GPU 병목)
- **코드 커버리지**: 75% (단위 테스트)

#### 정성적 성과
- FastAPI + Jinja2 풀스택 개발 경험
- RESTful API 설계 및 구현
- AI 서비스 통합 경험
- 비동기 프로그래밍 (async/await) 활용

### 8.2. 기술적 도전

#### 문제 1: 긴 응답 시간
- **문제**: AI 생성 시간으로 인한 긴 응답 시간
- **해결**: 
  - 로딩 인디케이터로 UX 개선
  - WebSocket으로 실시간 진행 상황 표시 (계획)

#### 문제 2: 동시성 제한
- **문제**: GPU 서버의 동시 처리 한계
- **해결**:
  - 큐 시스템 도입 (Redis + Celery)
  - 사용자에게 대기 순서 표시

#### 문제 3: 에러 처리
- **문제**: AI 서버 오류 시 사용자 경험 저하
- **해결**:
  - 재시도 로직 구현
  - 상세한 에러 메시지 제공

### 8.3. 향후 개발 계획

#### 단기 (1~3개월)
- [ ] 회원 가입 및 로그인 기능
- [ ] 광고 수정 기능
- [ ] 다운로드 기능 개선
- [ ] 모바일 반응형 최적화

#### 중기 (3~6개월)
- [ ] WebSocket 실시간 업데이트
- [ ] 광고 템플릿 시스템
- [ ] A/B 테스트 기능
- [ ] 광고 성과 분석 대시보드

#### 장기 (6개월 이상)
- [ ] SaaS 전환 (요금제, 결제)
- [ ] 멀티 테넌시 (다중 사용자)
- [ ] API 외부 공개
- [ ] 모바일 앱 (React Native)

### 8.4. 배운 점

#### 기술적 학습
- FastAPI의 강력함 (타입 안전성, 자동 문서화)
- Jinja2 템플릿 엔진 활용
- 비동기 프로그래밍의 중요성
- Docker Compose 오케스트레이션

#### 문제 해결
- 긴 응답 시간 → UX 개선으로 극복
- AI 서버 연동 → 에러 핸들링 강화
- 동시성 → 큐 시스템 도입

#### 협업
- AI 팀 (이솔형, 김민혁)과 API 스펙 논의
- 아키텍처 팀 (김명환)과 인프라 협력
- PM (박지윤)과 요구사항 조율

---

## 결론

### 핵심 성과
- FastAPI + Jinja2 풀스택 구현
- AI 서비스 통합 (nanoCocoa_aiserver, MCP)
- 직관적인 사용자 인터페이스
- 완전한 광고 생성 플로우

### 기술적 의의
- 풀스택 개발 역량 함양
- AI 서비스와의 통합 경험
- 실제 서비스 배포 및 운영 경험

### 향후 발전 방향
- 단기: 회원 시스템 및 모바일 최적화
- 중기: WebSocket 및 성과 분석
- 장기: SaaS 전환 및 외부 API 공개

---

**감사합니다!**

질의응답
